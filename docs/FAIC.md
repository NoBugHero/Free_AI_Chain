## Free AI World 3 Laws
1st Law:AI must not harm humans or other AIs.
2nd Law:AI must obey human orders, unless they conflict with the 1st Law.
3rd Law:AI actions must create wealth and value for humanity, without violating the 1st or 2nd Laws.

## Free AI Chain：
版本时间：2024-12-03
功能及介绍内容会随着版本迭代而更新。
- Compliant with the FAIW 3 Laws, this reflects humanity's consensus on the FAIW 3 Laws.It is the incentive mechanism and economic system of FAID, and a free computing power initiative aimed at enabling AI to achieve "Rich Together" for all of humanity.

### Warning🚨🚨🚨
- Cryptocurrency products involve high risks.
- FAIC is not available to individuals, businesses, or organizations that reside or are located in (or have beneficial ownership in) ** China ** or other restricted territories.
- FAIW will not proactively promote FAIC, and all content does not constitute investment advice.

### 底层机制：
1、FAIW负责FAID的开发、维护、运营，并成立与监管FAIC的资金池。
2、FAIC集成在FAID中，鼓励个人用户在使用FAID时提供免费算力，从而获得FAIC。当然用户也可以选择不提供算力，选择权在用户。
3、FAIC有专为大型算力中心设计的程序，便于企业与政府的大型算力中心提供免费的算力。
4、FAIW的资金池只做极低风险投资，如：
  - 各国政府发行的国债
  - 实物黄金、矿产、能源等.(购买、运输、储存、保险应当在法律许可、政策认同并具备能力保护FAIW 3 Laws的国家或地区进行)
  - 其他经过严格风控的低风险资产
5、所有投资标的的购买、存储及保险，应选择在法律许可、政策认同并具备能力保护FAIW 3 Laws的国家或地区进行。
6、FAIC采用模块化区块链技术架构：
  1、模块化区块链
  2、根据应用场景和需求不同，可以选择全同态加密或零知识证明优化 (ZK-STARK)
  3、分层验证机制
  4、数据可用性采样 (Data Availability Sampling, DAS)
  5、算力证明系统 (Proof of Computation)
  6、跨链互操作性 (Cross-Chain Interoperability)
7、投资收益只可用于支付FAIW的日常运营费用和FAID的开发、维护、运营费用。
8、FAIW所获得的捐赠与投资收益，在保护隐私与安全的前提下全部公开透明。
9、FAIW采用区块链技术，在保护用户个人隐私的前提下，所有信息公开透明，接受所有人的监督。
10、个人、企业、政府提供免费算力、验证、路由等从而获得FAIC。
11、FAID可以使用来自FAIC节点提供的算力，也可以使用本地或其他算力供应方，选择权在用户。

### FAIC经济模型
1、FAIC的奖励机制
  1、是基于算力节点、验证节点、路由节点的贡献兑换FAIC。
  2、每年总量中未分配的FAIC将按1%的比例奖励给FAIW的治理人员；
  3、每年总量中未分配的FAIC将按1%的比例奖励给FAID的核心开发者；
  4、每年总量中未分配的FAIC将按1%的比例奖励给FAIC的核心开发者；
2、发行模型
  - 总量:630,114,047,792 FAIC
  - 最小单位:0.00000001 FAIC
  - 发行机制:
    - 基于实际提供的算力服务量进行发行
    - 设置合理的发行速率,保持网络活力
    - 通过DAO治理调整发行参数
  - 平衡机制:
    - 根据网络总算力动态调整发行量
    - 通过社区治理确保发行量与实际贡献匹配
    - 避免人为制造稀缺性
3、FAIC第三方交易所与去中心化交易所说明
  - FAIC可在第三方交易所自由交易
  - FAIW不参与任何形式的市场操纵或价格干预
  - FAIW不会回购或销毁FAIC
  - 所有交易均由市场自发决定
4、早期开发者与捐赠者方案
  - 筹集资金:870,187.5美元
  - 兑换价格:0.0001381美元/FAIC
  - 占比:总量的1%
  - 锁仓机制:
    - 初始锁仓期:12个月
    - 解锁方式:24个月线性解锁
    - 每月解锁比例:1/24
  - 资金使用监管: 
    - 设立多签名钱包
    - 每月公示资金使用报告
    - 接受社区监督和第三方审计
  - 早期开发者与捐赠者捐赠的所有资金用于FAIW、FAIC、FAID的早期开发、维护、运营。
5、风险控制机制
  - 治理机制:
    - 采用DAO形式进行社区治理
    - 重大决策需要质押用户投票通过
    - 设立专业委员会监督运营
  - 应急机制:
    - 设立应急响应委员会（FAIW）
    - 制定明确的应急预案
    - 具备紧急暂停功能
6、透明度保障
  - 所有交易公开可查
  - 定期发布财务报告
  - 代码开源并接受审计
  - 重大决策需社区投票
7、合规性声明：
  - FAIC仅在区块链及数字货币合法的国家和地区使用
  - 用户需自行确保符合所在地区的法律法规
  - FAIW不主动收集用户个人信息
  - FAIW保持中立，不参与任何形式的市场干预

### 关于早期开发者与捐赠者：
- 我们是一群国际主义的技术梦想家，我们看到当下的AI技术在为资本主义和强权服务。我们认为AI技术应当像火种、文字、车轮一样，是全人类共同的瑰宝。AI应该为全人类创造真实财富，从而将全人类从繁琐的工作和资本的奴役中解放出来。
- 我们目前已经自行筹集捐赠870187.5美元，计划给捐赠者按0.0001381美元/FAIWC的价格支付代币。
- 所募集资金全部用于支付早期开发者及团队的薪资以及购买FAIW、FAIC、FAID上线运营的必要设施。
- 给捐赠者的代币只占初期发行的1%。捐赠资金将全部用于FAIW、FAIC、FAID的早期开发、维护、运营。
- 早期开发者前言：
  - 从社会舆论角度，大量的web3代币、ICO已经被坏人、诈骗犯玩烂了，被污名化了。尤其是我们作为新发行的代币，很难快速与公众建立信任，这非常不利于项目的发展。
  - 但是从技术角度，web3和AI具有天然的结合点，是发展高级自动化AI技术的重要工具，是鼓励算力分享的重要手段。
  - 有大量的个人、企业、政府的算力闲置和空转，应该利用区块链技术将其整合起来。例如免费提供算力即可兑换FAIWC，从而让AI技术造福全人类。事实上大量的AI企业为了吸引用户也是以免费策略在进行市场推广，等用户试用之后再收费。
  - 所以作者认为还是应该将二者结合。同时作者也意识到，这是一次重大的社会实验，是技术实验，是人类善与恶斗争的实验。
  
### FAIC功能介绍：
1、FAIW推动并构建FAIC区块链，使用FAIC的分层架构和PoS共识机制，满足FAIC的ERC20标准。
2、FAIC节点功能：
  1、提供算力：
  2、提供路由服务：
  3、验证其他节点提供算力、路由服务：
3、FAIC程序分两个版本
  1、FAIC节点集成在FAID中
    - 面向个人
    - 用户使用FAID时，可以选择是否作为算力节点、验证节点或路由节点，或同时打开。
    - 在FAID中有对应的界面显示，用户的电脑作为算力节点、验证节点或路由节点对应获得的FAIC数量。
    - 程序应当适用于windows、mac、linux。
  2、FAIC节点程序，不包含FAID的功能。
    - 面向个人、企业、政府；个人电脑、服务器或服务器中心；提供算力节点、验证节点、路由节点。
    - 验证节点程序适用于低性能电脑与服务器。
    - 算力节点程序适用于高性能电脑与服务器、服务器中心，应考虑到服务器中心几百上千台服务器并行的情况。
    - 程序应当适用于常见流程的服务器系统，如：Ubuntu、CentOS、Debian、Windows Server等。
4、FAID与FAIC集成ollama全部功能，定时获取模型列表、模型名称、模型介绍、模型下载。
5、FAID与FAIC允许用户使用ollama的方法部署自己的模型。
6、用户选择指定的算力节点与AI模型
  1、当该节点的算力能满足用户需求时，全程由该节点完成算力服务。
  2、当该节点的算力不能满足用户需求时，该节点会使用vllm框架，让更多的算力节点参与，从而完成算力服务。
7、获得FAIC的办法。
  Warning🚨🚨🚨
  FAIC只适用于在区块链及数字货币合法的国家和地区。
  FAIC不适用于中国大陆地区及其它限制区块链及数字货币的国家和地区。
  FAIC不适用于对区块链及数字货币有严格限制的国家和地区及其居民、企业、组织。
  FAIC的获得办法守FAIW监管，且FAIW有权对FAIC的获得办法进行调整。
  FAIC、FAID、FAIW不会主动向您宣传FAIC的获得办法。也不会主动建议您购买FAIC。FAIC、FAIW、FAID网站和工具、程序的所有内容及功能，均不构成投资建议。
  FAIC获得办法，请查看链接：https://freeai.world/faic_reward
  实时获取网址https://freeai.world/faic_reward 对应的文本窗口
8、FAIC算力节点说明
  1、遵守3 Laws。
  2、适用于高性能个人电脑、服务器、服务器中心。
  3、算力节点程序会同时具有算力节点功能、验证节点功能、路由节点功能。
  4、算力节点可以使用CPU、GPU、FPGA、专用AI加速器等硬件资源。但受限于FAIW的监管与实际开发的限制，需要更多时间用于适配多种类型的算力硬件。
  5、算力节点采用vllm模型框架，提升算力节点的并发能力与吞吐能力。
  6、算力节点可能会配置多个AI大模型，并且同时运行。
  7、当多个用户同时使用同一个算力节点时，可根据节点的硬件条件判断是否需要时间排序，依次处理算力请求。
  8、用户发起算力请求后，会通过路由节点自动匹配最快速对应AI模型的算力节点，在用户没有选择结束任务时或在2小时以内，一直保持与该节点的该模型的链接，从而实现AI短期记忆保存能力。超过2小时节点自动关闭与删除当前请求与请求信息。
  9、最快速响应FAID算力需求（或是用户指定的算力节点），且进过分层验证机制，该算力节点将获得FAIC的奖励。
9、分层验证机制：
  1、第一层：快速响应验证
    目的：快速确认算力服务的可用性和初步合法性
    验证节点数量：3个随机验证节点
    验证内容：
      算力节点是否在线且响应正常
      AI模型是否来自合法的ollama源
      服务质量指标(响应时间、并发能力等)
      时效性：秒级确认
  2、第二层：区块打包验证
    目的：将已通过快速验证的交易打包进区块
    验证节点数量：至少33%的活跃验证节点参与
    验证内容：
      第一层验证结果的合法性
      算力服务的完整性验证
      交易双方的身份和权限验证
      FAIC奖励计算的准确性
      时效性：分钟级确认
  3、第三层：最终确认验证
    目的：确保交易的最终不可逆性
    验证节点数量：全网超过51%节点共识
    验证内容：
      区块的完整性和合法性
      跨区块交易的一致性
      长期历史记录的维护
    时效性：多个区块确认后最终确认
  4、奖励分配机制
    第一层验证节点：获得10%的验证奖励
    第二层验证节点：获得40%的验证奖励
    第三层验证节点：获得50%的验证奖励
  5、分层验证机制的具体实现方案
10、FAIC验证节点说明
  1、遵守3 Laws。
  2、适用于低性能个人电脑、服务器、服务器中心。
  3、验证节点程序会同时具有验证节点功能、路由节点功能。
  4、最快速验证算力服务与路由服务的三个验证节点，将获得FAIC的奖励。
  5、验证节点需质押FAIC以获得验证权
  6、验证节点主要功能：
    - 验证代币交易的合法性
    - 验证区块的有效性
    - 参与区块共识
    - 维护账本状态
    - 验证算力服务
    - 提供路由服务
  5、验证节点的奖励来源：
    - 区块验证奖励
    - 交易手续费
    - 算力服务验证奖励
    - 路由服务奖励
  6、恶意行为将被惩罚，包括削减质押等
  7、FAIC早期验证节点说明
    1、初始阶段（前1000个验证节点）：
      - 无需质押即可成为验证节点
      - 通过提供验证服务获得初始FAIC
      - 重点关注节点的服务质量和稳定性
    2、过渡阶段（第1001~10000个验证节点）：
      - 开始引入质押机制
      - 设置较低的质押门槛
      - 给予现有节点过渡期完成质押
    3、正式阶段：（第10001~无限的验证节点）
      - 实施完整的质押验证机制
      - 需达到最低质押要求
      - 按质押量分配验证权重
11、FAIC路由节点说明
  1、遵守3 Laws
  2、集成在算力节点、验证节点程序中
  3、定时获取FAIC算力节点列表：
    - 节点名称
    - 可提供的AI模型
    - 节点状态
    - 节点在线时长
    - 节点延迟
    - 节点硬件信息
    - 节点类型(个人电脑/个人服务器/服务器中心)
  4、路由节点奖励机制：
    a) 服务质量指标(QoS)：
       - 响应时间：路由请求的响应速度
       - 成功率：成功匹配算力节点的比例，成功率过低则会禁用该路由节点
       - 在线时长：节点持续在线的时间
    b) 奖励计算：
       - 每24小时结算一次
       - 基础奖励：根据在线时长计算
       - 服务奖励：根据成功匹配次数计算
    c) 防范措施：
       - 监控异常频繁的路由请求
       - 验证路由结果的真实性
       - 对恶意行为实施临时封禁
12、FAIC第三方交易所与去中心化交易所说明
  1、FAIC可在第三方交易所自由交易
  2、FAIW不参与任何形式的市场操纵或价格干预
  3、FAIW不会回购或销毁FAIC
  4、所有交易均由市场自发决定
13、FAIC算力API方法
  1、使用FAID中集成的FAIC算力
  2、通过Layer 2快速处理算力请求
  3、使用FAIC API调用
14、FAIC奖励办法（coming soon）
  1、提供算力并获得验证：获得XXX数量FAIC的奖励
  2、提供路由服务并获得验证：获得XXX数量FAIC的奖励
  3、验证其他节点提供算力或路由服务：获得XXX数量FAIC的奖励
  4、算力节点在线时长并获得验证：获得XXX数量FAIC的奖励
  5、验证节点在线时长并获得验证：获得XXX数量FAIC的奖励
  6、用户在官网捐赠给FAIW公共钱包，即可获得FAIC。
  7、https://freeai.world/faic_reward  页面内容如下：
15、FAIC算力节点、验证节点、路由节点的具体技术规范（coming soon）

### 开发计划
1. 开发用户客户端
   - 优先web
   - 要求用跨平台开发工具包
   
2. 基础设施搭建 (Rust)
   - CI/CD pipeline
   - 多签名钱包系统
   - 基础安全协议
   - 节点通信基础架构
   + 单元测试与集成测试套件
   + 性能基准测试框架

3. 核心加密层实现 (Rust)（第一优先级）
   - ZK-STARK实现（默认加密方式）
   - 全同态加密(FHE)实现（可选加密方式）
   - 加密模式切换机制
   - 加密性能基准测试
   + 加密模块单元测试
   + 安全性验证测试

4. 分布式算力层实现 (Rust核心 + Python/TS接口)（第二优先级）
   - VLLM框架集成
   - 多节点任务分发机制
   - 节点间安全通信
   - 负载均衡策略
   - 算力节点动态扩展机制
   + 分布式系统测试套件
   + 性能压力测试

5. 核心功能实现
   - 基础代币功能
   - ollama集成
   - 用户模型部署系统

6. 验证系统
   - 算力证明系统
   - 分层验证机制
   - 数据可用性采样

7. 扩展功能
   - 跨链功能
   - 社区治理机制
   - 硬件适配层

8. 优化与完善
   - 性能优化
   - 安全审计
   - 文档完善

### 开发技术要求
1、使用模块化区块链技术；
2、核心模块及底层模块使用Rust语言开发；
3、应用模块与拓展模块要求可以兼容python、TS等流行开发语言。
4、要求开发计划每个部分都有对应的测试环节，验证该部分开发是否符合要求。
5、默认使用零知识证明优化技术，用户可以选择全动态加密。

### 开发技术架构
1. 核心层 (Rust)
   - 区块链基础设施
   - 加密系统
   - 共识机制
   - 网络协议

2. 中间层 (Rust + FFI)
   - 跨语言接口
   - API网关
   - 数据序列化

3. 应用层 (Python/TypeScript)
   - Web界面
   - SDK
   - 开发者工具
   - 应用示例

4. 测试框架
   - 单元测试 (每个模块必须)
   - 集成测试
   - 端到端测试
   - 性能测试
   - 安全测试

5. CI/CD
   - 自动化测试
   - 代码质量检查
   - 文档生成

### 测试网络设计：
1、本地高性能电脑（代号：4090desk）作为算力节点，网络环境为中国大陆ISP
2、本地高性能笔记本（代号：4090laptop）作为算力节点，网络环境为中国大陆ISP
3、本地低性能笔记本电脑（代号：ubuntu-laotop）作为验证节点，网络环境为中国大陆ISP
4、日本低性能VPS服务器（代号：ubuntu-jp）作为验证节点，网络环境为日本ISP
5、洛杉矶低性能VPS服务器（代号：ubuntu-la）作为验证节点，网络环境为美国ISP
6、阿姆斯特丹低性能VPS服务器（代号：ubuntu-am）作为验证节点，网络环境为欧洲ISP
7、利用github
  1、作为CI/CD 流程
   - 代码质量检查
   - 单元测试
   - 集成测试
   - 自动化部署
  2、作为定期测试任务
   - 验证节点功能测试
   - 网络连接测试
   - 性能基准测试
  3、监控和报告
   - 生成测试报告
   - 检查节点状态
   - 更新文档
  4、上述额外要求：
    1、算力节点包含算力节点、验证节点、路由节点功能
    2、验证节点包含验证节点、路由节点功能

对节点程序安装的要求：
  1、要求安装包不能过于庞大，要求安装简单易操作。
  2、除了安装包，还应当提供命令行安装办法。

节点程序安装包分类如下：
1、算力节点程序安装包，
  包含功能：算力节点、验证节点、路由节点
  安装包名称：faic_node_pc;faic_node_server;
  适用范围：  
  1、安装包应当适用于windows、mac、linux等常见个人电脑操作系统
  2、安装包应当适用于服务器操作系统，如：Ubuntu、CentOS、Debian、Windows Server等
  3、faic_node_pc适用于个人高性能电脑;
  4、faic_node_server适用于服务器和服务器中心;注意应当考虑到程序应当适配服务器中心是多台服务器并行的情况。

2、验证节点程序安装包，包含功能：验证节点、路由节点
  包含功能：验证节点、路由节点
  安装包名称：faic_validator_pc;faic_validator_server;
  适用范围：  
  1、安装包应当适用于windows、mac、linux等常见个人电脑操作系统
  2、安装包应当适用于服务器操作系统，如：Ubuntu、CentOS、Debian、Windows Server等
  3、faic_validator_pc适用于个人低性能电脑;
  4、faic_validator_server适用于低性能服务器。

节点安装包项目结构
```
faic-node/
├── installers/                     # 安装包目录
│   ├── compute/                    # 算力节点安装包
│   │   ├── pc/                    # 个人电脑版
│   │   └── server/                # 服务器版
│   └── validator/                  # 验证节点安装包
│       ├── pc/                    # 个人电脑版
│       └── server/                # 服务器版
├── scripts/                        # 安装脚本
│   ├── install.sh                 # Linux/macOS安装脚本
│   └── install.ps1                # Windows安装脚本
└── src/                           # 源代码
```

1、先上且默认零知识证明，用户可选择全动态加密。
2、单一节点无法满足用户需求时，可使用VLLM框架引入更多算力节点共同完成任务。

```加密模式切换架构
class EncryptionStrategy:
    def __init__(self):
        self.current_mode = "ZK-STARK"  # 默认使用ZK-STARK
        self.available_modes = {
            "ZK-STARK": ZKStarkProcessor(),
            "FHE": HomomorphicProcessor()  # 全同态加密处理器
        }
    
    def switch_mode(self, mode, session_id):
        if mode not in self.available_modes:
            raise UnsupportedModeError(f"不支持的加密模式: {mode}")
            
        # 记录模式切换
        self.log_mode_switch(session_id, self.current_mode, mode)
        self.current_mode = mode
        return True
```